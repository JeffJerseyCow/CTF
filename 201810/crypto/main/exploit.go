package main

import (
  "os"
  "fmt"
  "net"
  "strings"
)

func check(err error) {
  if err != nil {
    panic(err)
  }
}

func decrypt(conn net.Conn) {
  resp := make([]byte, 1024)
  prevResp := make([]byte, 1024)

  // read data loop
  first := true
  loop:
    for {
      readLen, err := conn.Read(resp)
      check(err)
      if readLen <= 0 {
        continue
      }

      // special case first read
      if first {
        for i := 0; i < readLen; i ++ {
          prevResp[i] = resp[i]
        }
        first = false
      }

      // decrypt if bytes are different
      count := 0
      for i := 0; i < readLen; i ++ {
        if resp[i] != prevResp[i] {
          fmt.Printf("%c", resp[i] ^ prevResp[i])
          if count ++; count >= 34 {
            fmt.Println()
            break loop
          }
        }
      }

      // write byte to continue
      conn.Write([]byte{0x00})
    }
}

func main() {
  if len(os.Args) != 3 {
    fmt.Fprintf(os.Stderr, "Usage: %s {IPv4} {Port}\n", os.Args[0])
    os.Exit(1)
  }
  if len(os.Args[1]) > 15 {
    fmt.Fprintf(os.Stderr, "[-] IPv4 address '%s' too long\n", os.Args[1])
    os.Exit(1)
  }
  if len(os.Args[2]) > 5 {
    fmt.Fprintf(os.Stderr, "[-] Destination port '%s' too long\n", os.Args[2])
    os.Exit(1)
  }

  // create service
  service := strings.Join([]string{os.Args[1], os.Args[2]}, ":")
  tcpAddr, err := net.ResolveTCPAddr("tcp4", service)
  check(err)

  // connect
  conn, err := net.DialTCP("tcp4", nil, tcpAddr)
  check(err)
  decrypt(conn)
}
